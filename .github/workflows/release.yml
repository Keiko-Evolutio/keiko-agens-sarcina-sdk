# GitHub Actions Workflow für KEI-Agent Python SDK Release und PyPI Publishing
# Automatisiert das Erstellen und Veröffentlichen von Releases

name: 🚀 Release & Publish

on:
  # Trigger bei Git-Tags (sowohl v*.*.* als auch *.*.*)
  push:
    tags:
      - "v*.*.*"
      - "v*.*.*-alpha.*"
      - "v*.*.*-beta.*"
      - "v*.*.*-rc.*"
      - "*.*.*"
      - "*.*.*-alpha.*"
      - "*.*.*-beta.*"
      - "*.*.*-rc.*"

  # Manueller Trigger für Testing
  workflow_dispatch:
    inputs:
      version:
        description: "Version to release (e.g., 1.0.0)"
        required: true
        type: string
      publish_to_pypi:
        description: "Publish to PyPI"
        required: false
        default: false
        type: boolean
      publish_to_test_pypi:
        description: "Publish to TestPyPI"
        required: false
        default: true
        type: boolean

# Berechtigungen
permissions:
  contents: write
  id-token: write # Für PyPI Trusted Publishing

# Umgebungsvariablen
env:
  PYTHONUNBUFFERED: 1
  PYTHONDONTWRITEBYTECODE: 1
  PIP_DISABLE_PIP_VERSION_CHECK: 1
  PYTHONIOENCODING: utf-8

jobs:
  # Job 1: Release Validation
  validate-release:
    name: 🔍 Validate Release
    runs-on: ubuntu-latest

    outputs:
      version: ${{ steps.version.outputs.version }}
      is_prerelease: ${{ steps.version.outputs.is_prerelease }}
      normalized_version: ${{ steps.version.outputs.normalized_version }}

    steps:
      # Repository auschecken
      - name: 📥 Checkout Repository
        uses: actions/checkout@v5
        with:
          fetch-depth: 0 # Vollständige Historie für Changelog

      # Python Setup
      - name: 🐍 Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"
          cache: "pip"

      # Dependencies installieren
      - name: 📦 Install Dependencies
        shell: bash
        run: |
          python -m pip install --upgrade pip
          echo "INFO: Installiere ALLE Dependencies DIREKT..."
          pip install "httpx>=0.24.0,<1.0.0" "aiohttp>=3.8.0,<4.0.0" "websockets>=11.0.0,<12.0.0" "pydantic>=2.0.0,<3.0.0" "tenacity>=8.2.0,<9.0.0" "msgpack>=1.0.0,<2.0.0" "packaging>=21.0" "python-dateutil>=2.8.0" "psutil>=5.9.0,<8.0.0" "structlog>=23.1.0,<26.0.0" "typing-extensions>=4.0.0"
          pip install "opentelemetry-api>=1.20.0,<2.0.0" "opentelemetry-sdk>=1.20.0,<2.0.0" "opentelemetry-exporter-jaeger>=1.20.0,<2.0.0" "opentelemetry-exporter-zipkin-json>=1.20.0,<2.0.0" "opentelemetry-propagator-b3>=1.20.0,<2.0.0"
          pip install "pytest>=7.4.0,<8.0.0" "pytest-asyncio>=0.21.0,<1.0.0" "pytest-mock>=3.11.0,<4.0.0" "pytest-benchmark>=4.0.0,<6.0.0" "ruff>=0.1.0,<1.0.0" "mypy>=1.5.0,<2.0.0" "bandit>=1.7.0,<2.0.0" "pre-commit>=3.4.0,<4.0.0" "twine>=4.0.0,<5.0.0" "build>=0.10.0,<2.0.0"
          pip install -e "." || echo "WARNING: Editable install fehlgeschlagen, aber Dependencies sind installiert"
          echo "SUCCESS: Dependencies installiert"
          python -c "import httpx, aiohttp; print('SUCCESS: Kritische Dependencies verfügbar')"

      # Version extrahieren
      - name: 🏷️ Extract Version
        id: version
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            VERSION="${{ github.event.inputs.version }}"
          else
            # Tag ohne v Präfix extrahieren (sowohl v0.1.0 als auch 0.1.0 unterstützen)
            VERSION=${GITHUB_REF#refs/tags/}
            VERSION=${VERSION#v}  # Entfernt v falls vorhanden
          fi

          echo "version=$VERSION" >> $GITHUB_OUTPUT

          # Pre-Release Check und Normalisierung über packaging (PEP 440)
          export VERSION GITHUB_OUTPUT
          python - <<'PY'
          import os
          from packaging.version import Version

          v = os.environ.get('VERSION', '').strip()
          is_pr = Version(v).is_prerelease
          print(f"🔖 Pre-Release Version: {v}" if is_pr else f"🔖 Release Version: {v}")
          norm = str(Version(v))
          with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
              f.write(f"is_prerelease={'true' if is_pr else 'false'}\n")
              f.write(f"normalized_version={norm}\n")
          PY

      # Version in pyproject.toml validieren
      - name: ✅ Validate Version
        run: |
          # Python 3.11+ hat tomllib, für ältere Versionen verwenden wir toml
          export TAG_VERSION="${{ steps.version.outputs.version }}"
          python - <<'PY'
          import os, sys
          try:
              import tomllib
              with open('pyproject.toml', 'rb') as f:
                  data = tomllib.load(f)
          except Exception:
              import toml
              data = toml.load('pyproject.toml')

          py_ver = data['project']['version']
          tag_ver = os.environ['TAG_VERSION']

          from packaging.version import Version
          py_norm = Version(py_ver)
          tag_norm = Version(tag_ver)

          print(f"📋 pyproject.toml Version: {py_ver}")
          print(f"📋 Tag Version: {tag_ver}")
          print(f"📋 Normalisiert (PEP 440): pyproject={py_norm}, tag={tag_norm}")

          if py_norm != tag_norm:
              print(f"❌ Version-Mismatch zwischen pyproject.toml ({py_ver}) und Tag ({tag_ver})", file=sys.stderr)
              sys.exit(1)

          print(f"✅ Version validiert: {tag_norm}")
          PY

      # Qualitätsprüfungen
      - name: 🔍 Quality Checks
        run: |
          echo "🔍 Führe Release-Qualitätsprüfungen aus..."
          make quality

      # Tests ausführen
      - name: 🧪 Run Tests
        run: |
          echo "🧪 Führe alle Tests aus..."
          make test-all

  # Job 2: Build Package
  build-package:
    name: 🏗️ Build Package
    runs-on: ubuntu-latest
    needs: validate-release

    steps:
      # Repository auschecken
      - name: 📥 Checkout Repository
        uses: actions/checkout@v5

      # Python Setup
      - name: 🐍 Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"
          cache: "pip"

      # Dependencies installieren
      - name: 📦 Install Dependencies
        shell: bash
        run: |
          python -m pip install --upgrade pip
          echo "INFO: Installiere ALLE Dependencies DIREKT..."
          pip install "httpx>=0.24.0,<1.0.0" "aiohttp>=3.8.0,<4.0.0" "websockets>=11.0.0,<12.0.0" "pydantic>=2.0.0,<3.0.0" "tenacity>=8.2.0,<9.0.0" "msgpack>=1.0.0,<2.0.0" "packaging>=21.0" "python-dateutil>=2.8.0" "psutil>=5.9.0,<8.0.0" "structlog>=23.1.0,<26.0.0" "typing-extensions>=4.0.0"
          pip install "opentelemetry-api>=1.20.0,<2.0.0" "opentelemetry-sdk>=1.20.0,<2.0.0" "opentelemetry-exporter-jaeger>=1.20.0,<2.0.0" "opentelemetry-exporter-zipkin-json>=1.20.0,<2.0.0" "opentelemetry-propagator-b3>=1.20.0,<2.0.0"
          pip install "pytest>=7.4.0,<8.0.0" "pytest-asyncio>=0.21.0,<1.0.0" "pytest-mock>=3.11.0,<4.0.0" "pytest-benchmark>=4.0.0,<6.0.0" "ruff>=0.1.0,<1.0.0" "mypy>=1.5.0,<2.0.0" "bandit>=1.7.0,<2.0.0" "pre-commit>=3.4.0,<4.0.0" "twine>=4.0.0,<5.0.0" "build>=0.10.0,<2.0.0"
          pip install -e "." || echo "WARNING: Editable install fehlgeschlagen, aber Dependencies sind installiert"
          echo "SUCCESS: Dependencies installiert"
          python -c "import httpx, aiohttp; print('SUCCESS: Kritische Dependencies verfügbar')"

      # Package erstellen mit build_and_publish.py
      - name: 🏗️ Build Package
        run: |
          echo "🏗️ Erstelle Package mit build_and_publish.py..."
          python build_and_publish.py --build-only

      # Build-Artefakte validieren
      - name: ✅ Validate Build
        run: |
          echo "✅ Validiere Build-Artefakte..."
          make check-build

          # Zusätzliche Validierungen
          echo "📊 Build-Statistiken:"
          ls -la dist/

          # Wheel-Inhalt prüfen (ohne BrokenPipe durch head)
          python - <<'PY'
          import glob, zipfile
          files = glob.glob('dist/*.whl')
          if files:
              with zipfile.ZipFile(files[0]) as z:
                  for info in z.infolist()[:20]:
                      print(f"{info.filename:46} {info.file_size:12d}")
          PY

          # Metadaten prüfen (nicht blockierend wegen Twine-Import-Bug)
          python -m twine check dist/* || echo "⚠️ Twine check Warnung ignoriert"

      # Build-Artefakte hochladen
      - name: 📤 Upload Build Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: dist-packages-${{ needs.validate-release.outputs.normalized_version }}
          path: dist/
          retention-days: 90

  # Job 3: TestPyPI Publishing
  publish-test:
    name: 🧪 Publish to TestPyPI
    runs-on: ubuntu-latest
    needs: [validate-release, build-package]
    if: |
      (github.event_name == 'push' && startsWith(github.ref, 'refs/tags/')) ||
      (github.event_name == 'workflow_dispatch' && github.event.inputs.publish_to_test_pypi == 'true')

    environment:
      name: test-pypi
      url: https://test.pypi.org/project/kei_agent_py_sdk/

    steps:
      # Build-Artefakte herunterladen
      - name: 📥 Download Build Artifacts
        uses: actions/download-artifact@v5
        with:
          name: dist-packages-${{ needs.validate-release.outputs.normalized_version }}
          path: dist/

      # TestPyPI Upload
      - name: 🧪 Publish to TestPyPI
        uses: pypa/gh-action-pypi-publish@release/v1
        with:
          repository-url: https://test.pypi.org/legacy/
          verbose: true

      # TestPyPI Installation testen
      - name: ✅ Test TestPyPI Installation
        run: |
          echo "✅ Teste Installation von TestPyPI..."
          python -m pip install --index-url https://test.pypi.org/simple/ \
            --extra-index-url https://pypi.org/simple/ \
            kei_agent_py_sdk==${{ needs.validate-release.outputs.normalized_version }}

          # Basis-Import testen
          python -c "import kei_agent; print(f'✅ Import erfolgreich: {kei_agent.__version__}')"

  # Job 4: PyPI Publishing (nur für finale Releases)
  publish-prod:
    name: 🚀 Publish to PyPI
    runs-on: ubuntu-latest
    needs: [validate-release, build-package, publish-test]
    if: |
      (github.event_name == 'push' && startsWith(github.ref, 'refs/tags/')) ||
      (github.event_name == 'workflow_dispatch' && github.event.inputs.publish_to_pypi == 'true')

    steps:
      # Build-Artefakte herunterladen
      - name: 📥 Download Build Artifacts
        uses: actions/download-artifact@v5
        with:
          name: dist-packages-${{ needs.validate-release.outputs.normalized_version }}
          path: dist/

      # PyPI Upload
      - name: 🚀 Publish to PyPI
        uses: pypa/gh-action-pypi-publish@release/v1
        with:
          verbose: true

      # PyPI Installation testen
      - name: ✅ Test PyPI Installation
        run: |
          echo "✅ Teste Installation von PyPI..."
          sleep 60  # Warten bis Package verfügbar ist
          python -m pip install kei_agent_py_sdk==${{ needs.validate-release.outputs.normalized_version }}

          # Basis-Import testen
          python -c "import kei_agent; print(f'✅ Import erfolgreich: {kei_agent.__version__}')"

  # Job 5: GitHub Release erstellen
  create-release:
    name: 📝 Create GitHub Release
    runs-on: ubuntu-latest
    needs: [validate-release, build-package]
    if: github.event_name == 'push' && startsWith(github.ref, 'refs/tags/')

    steps:
      # Repository auschecken
      - name: 📥 Checkout Repository
        uses: actions/checkout@v5
        with:
          fetch-depth: 0

      # Build-Artefakte herunterladen
      - name: 📥 Download Build Artifacts
        uses: actions/download-artifact@v5
        with:
          name: dist-packages-${{ needs.validate-release.outputs.version }}
          path: dist/

      # Release Notes generieren
      - name: 📝 Generate Release Notes
        id: release_notes
        run: |
          VERSION="${{ needs.validate-release.outputs.normalized_version }}"

          # Changelog aus Git-Tags generieren
          PREVIOUS_TAG=$(git describe --tags --abbrev=0 HEAD^ 2>/dev/null || echo "")

          if [[ -n "$PREVIOUS_TAG" ]]; then
            echo "📋 Änderungen seit $PREVIOUS_TAG:"
            CHANGELOG=$(git log --pretty=format:"- %s (%h)" $PREVIOUS_TAG..HEAD)
          else
            echo "📋 Erste Release:"
            CHANGELOG=$(git log --pretty=format:"- %s (%h)" HEAD)
          fi

          # Release Notes erstellen
          cat > release_notes.md << EOF
          # KEI-Agent Python SDK v$VERSION

          ## 🚀 Änderungen

          $CHANGELOG

          ## 📦 Installation

          \`\`\`bash
          pip install kei-agent-sdk==$VERSION
          \`\`\`

          ## 📚 Dokumentation

          - [Dokumentation](https://docs.kei-agent-framework.com)
          - [API-Referenz](https://docs.kei-agent-framework.com/api/)
          - [Beispiele](https://docs.kei-agent-framework.com/examples/)

          ## 🔗 Links

          - [PyPI Package](https://pypi.org/project/kei_agent_py_sdk/$VERSION/)
          - [GitHub Repository](https://github.com/oscharko-dev/kei-agent-py-sdk)
          EOF

          echo "release_notes_file=release_notes.md" >> $GITHUB_OUTPUT

      # GitHub Release erstellen
      - name: 🏷️ Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: v${{ needs.validate-release.outputs.version }}
          name: KEI-Agent Python SDK v${{ needs.validate-release.outputs.version }}
          body_path: release_notes.md
          files: dist/*
          prerelease: ${{ needs.validate-release.outputs.is_prerelease == 'true' }}
          generate_release_notes: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
